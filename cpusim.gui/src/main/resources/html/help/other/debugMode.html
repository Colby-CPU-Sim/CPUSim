<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;
      charset=windows-1252">
    <title>Debug Mode</title>
  </head>
  <body bgcolor="#FFFFFF" link="#0000ff" vlink="#800080">
    <h3 align="CENTER"> <b><font color="#0000ff" face="Arial">Debug
          Mode</font></b> </h3>
    <p> <font face="Palatino">Debug mode provides you with several
        tools for finding bugs in your code, including the following:</font>
    </p>
    <ol>
      <li><font face="Palatino">You can step through the code one
          machine instruction or one microinstruction at a time. As you
          do so, the name of the current machine instruction being
          executed is displayed on the right end of the debug toolbar,
          along with the microinstructions composing it, which are
          displayed in a scroll box. The specific microinstruction being
          executed is highlighted in the scroll box. If you step by
          microinstruction, then any register and RAM cells that are
          changed during execution are outlined in green. After each
          step you can inspect and change the values stored in any
          register or RAM. Note: At the beginning of each machine cycle
          the fetch sequence is listed as the current instruction in the
          debug toolbar and its microinstruction sequence is listed,
          because it is what is executed next. However, after executing
          the Decode microinstruction in the fetch sequence, the toolbar
          will display the name of the decoded instruction and its
          microinstruction sequence. </font></li>
      <li><font face="Palatino">You can back up one machine instruction
          at a time, which resets the values of the registers and RAMs
          to their state at the start of the last machine cycle.</font></li>
      <li><font face="Palatino">You can also back up one
          microinstruction at a time, which resets the values of the
          registers and RAMs to their state at the start of the last
          microinstruction.</font></li>
      <li><font face="Palatino">Using the Highlighting tab within the "<a
            href="../windows/OptionsDialog.html">Options Dialog</a>",
          you can specify cells of RAMs to be highlighted as you step
          through the code. For example, suppose you have a stack and a
          stack top register. You can tell CPU Sim to highlight, after
          each step, the row of the stack RAM whose address is in the
          stack top register. Similarly, if you have a program counter,
          you can tell CPU Sim to highlight the row of the code RAM
          whose address is in the program counter during each step. In
          the latter case, CPU Sim will also highlight the row of source
          code corresponding to the highlighted row of RAM, as you step
          through the code. </font></li>
      <li><font face="Palatino">You can specify break points at any line
          of code by clicking on the left side of the line, which will
          cause a red circle to appear there. When that line of code is
          about to be executed, execution halts instead. When the
          program has halted, background of the red circle is
          highlighted in orange in the text editor. At that point, you
          can inspect and/or edit the contents of all registers and RAMs
          and back up or resume execution. </font></li>
    </ol>
    <p> <font face="Palatino">To enter debug mode, select the "Debug
        Mode" menu item in the <strong>Execute</strong> menu. This
        action will cause a debug toolbar to appear below the main menu
        (see Figure 1). </font> </p>
    <p class="p3" align="CENTER"> <font face="Palatino"><img
          src="../generalHelp/tour/DebugToolbar.jpg" width="500"
          height="40"><br>
        Figure 1. The debugging toolbar</font> </p>
    <p> <font face="Palatino">The label to the left of the scroll box
        on the right end of the toolbar always displays the machine
        instruction or fetch sequence that is about to be or is
        currently being executed. In Figure 1 above, the fetch sequence
        is about to be executed. At the start of each machine cycle, the
        toolbar displays the fetch sequence first. The scroll box lists
        the microinstructions comprising the current machine instruction
        or fetch sequence. The microinstruction that is to be executed
        next is always highlighted.</font> </p>
    <p> <b><i><font color="#0000ff" face="Arial">Go</font></i></b> </p>
    <p> <font face="Palatino">The "Go" button causes execution to
        continue without interruption until one of the following
        happens: </font> </p>
    <ol type="a">
      <li><font face="Palatino">a condition bit that is designated as
          halt bit has its value set to 1</font></li>
      <li><font face="Palatino">a break point is reached</font></li>
      <li><font face="Palatino">the user stops the current execution by
          choosing "Stop" from the <b> Execute </b>menu </font></li>
      <li><font face="Palatino">the user chooses Cancel when an input
          dialog appears</font></li>
      <li><font face="Palatino">an error occurs.</font></li>
    </ol>
    <p> <b><i><font color="#0000ff" face="Arial">Step by Instr</font></i></b>
    </p>
    <p> <font face="Palatino">The "Step by Instr" button causes the
        execution of one full machine cycle (a fetch sequence followed
        by the execute sequence of the instruction decoded by the fetch
        sequence). If part of a machine cycle has already been executed
        (for example, by means of the "Step by Micro" button or if the
        execution of a whole cycle was halted because of an error), then
        clicking this button causes the rest of that machine cycle to be
        executed. The name of the machine instruction currently being
        executed is displayed in the label to the scroll box at the
        right end of the toolbar.</font> </p>
    <p> <b><i><font color="#0000ff" face="Arial">Step by Micro</font></i></b>
    </p>
    <p> <font face="Palatino">The "Step by Micro" button causes
        execution of one microinstruction in the current fetch or
        execute sequence. The name of the microinstruction to be
        executed is highlighted in the scroll box on the right end of
        the debug toolbar. After execution of the microinstruction, any
        values in registers that were changed by it are highlighted with
        a green border.</font> </p>
    <p> <b><i><font color="#0000ff" face="Arial">Backup one Instr</font></i></b>
    </p>
    <p> <font face="Palatino">The "Backup one Instr" button causes the
        machine to back up to the state it was in at the beginning of
        the last machine cycle. You can continue backing up one machine
        instruction at a time all the way to the initial state of the
        machine when you entered debug mode.</font> </p>
    <p> <b><i><font color="#0000ff" face="Arial">Backup one Micro</font></i></b>
    </p>
    <p> <font face="Palatino">The "Backup one Micro" button causes the
        machine to back up to the state it was in at the beginning of
        the previous microinstruction. You can continue backing up one
        microinstruction at a time all the way to the initial state of
        the machine. If you have been backing up by microinstruction and
        then use the "Backup one Instr" button, the machine will back up
        to the state it was in at the beginning of the last machine
        cycle.</font> </p>
    <p> <b><i><font color="#0000ff" face="Arial">Start over</font></i></b>
    </p>
    <p> <font face="Palatino">The "Start over" button causes the
        machine to back up all at once to the initial state it was in
        when the user started executing the current program in debug
        mode. This action also causes the IO to be flushed and reset and
        the control unit to be reset to begin execution again at the
        start of the fetch sequence. This button functions similarly to
        "Reset everything" in the <b>Execute </b>menu except that this
        button does not clear the registers and RAMs (unless they were
        clear when debug mode was entered). </font> </p>
    <p> <font face="Palatino"><b><font color="#0000ff" face="Arial">Keyboard

            Shortcuts for buttons in the debug toolbar</font></b></font>
    </p>
    <p> <font face="Palatino">The six buttons in the debug toolbar have
        keyboard shortcuts you can use. Here is a list of them. Replace
        the Control key with the Command key on Macintosh computers.</font></p>
    <pre><i>Button</i>              <i>Shortcut</i>
Go                  Ctrl-Alt-G
Step by Instr       Ctrl-Alt-I
Step by Micro       Ctrl-Alt-M
Backup one Instr    Ctrl-Alt-B
Backup one Micro    Ctrl-Alt-K
Start Over          Ctrl-Alt-S</pre>
    <p><font face="Palatino"> These keyboard shortcuts cannot be changed
        in the <a href="../windows/preferences.html">Preferences</a>
        dialog like other keyboard shortcuts can. </font> </p>
    <p> <font face="Palatino"><b><font color="#0000ff" face="Arial">Setting


            Break points in the program</font></b></font> </p>
    <p> <font face="Palatino">The grey column that appears along the
        left edge in the text editor is used for setting break points in
        your program. To set a break point, click in the grey column and
        a red dot will appear there. To clear a break point, just click
        on the red circle. CPU Sim will halt execution whenever it
        reaches an instruction that has a break point set. More
        precisely, at the beginning of each machine cycle, CPU Sim looks
        at the value in the program counter register (specified in the <a
          href="../windows/OptionsDialog.html">Options dialog</a>).&nbsp;
        It treats that value as an address into the code store. It then
        checks the code store to see whether the instruction at that
        address corresponds to a line of assembly code with a break
        point set.&nbsp; If so, it halts. At that point, you can inspect
        and/or change the contents of any register or RAM and continue
        execution or back up.&nbsp; Note that break points work only
        when CPU Sim is in debug mode.</font> </p>
    <p> <font face="Palatino"><font face="Palatino"> </font></font> </p>
    <p> <font face="Palatino"><b><font color="#0000ff" face="Arial">Notes</font></b></font>
    </p>
    <ol type="a">
      <li><font face="Palatino">Between every step forward or backward,
          you can inspect and edit any values in the registers or RAMs.
        </font></li>
      <li><font face="Palatino">One way to find errors in your programs
          is to step by machine instruction until you reach a point
          where an error has already occurred. Then back up one
          microinstruction at a time until you reach the precise
          microinstruction in which the problem occurred. </font></li>
      <li><font face="Palatino">If your program seems to be in an
          infinite loop, you can to choose "Stop" from the Execute menu
          to halt the execution.</font></li>
      <li><font face="Palatino">You are able to back up when in debug
          mode because CPU Sim saves the state of the machine just
          before executing each microinstruction. However, if your
          program is in an infinite loop, CPU Sim will quickly run out
          of memory. To avoid this problem, CPU Sim saves at most the
          first 10,000 states.</font></li>
    </ol>
  </body>
</html>
